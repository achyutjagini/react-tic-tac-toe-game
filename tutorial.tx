Next, you’ll want to change the value of a square from empty to “X”
when the user clicks on the square. With how you’ve built the board so 
far you would need to copy-paste the code that updates the square
nine times (once for each square you have)! Instead of copy-pasting,
React’s component architecture allows you to create a reusable component to
 avoid messy, duplicated code.

First, you are going to copy the line defining your first square (<button 
className="square">1</button>) from your Board component into a new
 Square component:

function Square() {
  return <button className="square">1</button>;
}

export default function Board() {
  // ...
}


Then you’ll update the Board component to render that
 Square component using JSX syntax:

// ...
export default function Board() {
  return (
    <>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
    </>
  );
}

Notice how unlike the browser divs, your own components Board and Square must 
start with a capital letter.

Let’s take a look:

Let’s fill the Square component with an X when you click it. Declare a function
called handleClick inside of the Square. Then, add onClick to the props of the
button JSX element returned from the Square component:

function Square({ value }) {
  function handleClick() {
    console.log('clicked!');
  }

  return (
    <button
      className="square"
      onClick={handleClick}
    >
      {value}
    </button>
  );
}


As a next step, you want the Square component to “remember” that it got clicked, 
and fill it with an “X” mark. To “remember” things, components use state.

React provides a special function called useState that you can call from 
your component to let it “remember” things. Let’s store the current value
 of the Square in state, and change it when the Square is clicked.

Import useState at the top of the file. Remove the value prop from the 
Square component. Instead, add a new line at the start of the Square
component that calls useState. Have it return a state variable called value:


Currently, each Square component maintains a part of the game’s state. To check for a winner 
in a tic-tac-toe game, the Board would need to somehow know the state of each of the 9 Square
' components.

How would you approach that? At first, you might guess that the Board needs to “ask”
each Square for that Square’s state. Although this approach is technically possible
in React, we discourage it because the code becomes difficult to understand, 
susceptible to bugs, and hard to refactor. Instead, the best approach is to 
store the game’s state in the parent Board component instead of in each Square. 
The Board component can tell each Square what to display by passing a prop, like you did when you passed a number to each Square.

To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with the parent component.

Lifting state into a parent component is common when React components are refactored.

Let’s take this opportunity to try it out. Edit the Board component so that it declares a state variable named squares that defaults to an array of 9 nulls corresponding to the 9 squares